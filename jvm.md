# JVM

## 内存区域

### 程序计数器
1. 一块较小的内存空间，可以看作是当前线程缩执行的字节码的行码指示器
2. 线程私有
3. 当执行方法计器记录的是正在执行的虚拟机字节码指定的地址如果执行的是native方法，计数器的值为空
4. 唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

### 虚拟机栈
1. 线程私有，生命周期与线程相同
2. 描述的是方法执行的内存模型：每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法的调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程
3. 局部变量表保存的是各种基本数据类型、对象引用和returnAddress(执行了一条字节码指令的地址)
4. 64位的long和double会占用两个局部变量空间，其他的只占用一个，局部变量表所需的内存空间在 编译期间 完成分配。当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小
5. 如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError。如果虚拟机无法申请到足够的内存将会抛出OutOfMemoryError

操作数栈：和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作—压栈和出栈—来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。


### 本地方法栈
1. 为虚拟机使用native方法服务
2. 虚拟机规范中对本地方法栈中方法使用的语言，使用方式与数据结构没有强制规定，不同虚拟机可自由实现
3. 本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常

### java堆
1. 所有线程共享的内存区域，在虚拟机启动时创建
2. 唯一目的为存放对象实例，几乎所有的对象实例都在这里分配内存
3. 垃圾收集器管理的主要区域
4. 通过-Xmx -Xms配置区域大小
5. 没有足够内存进行实例分配，并且无法扩展时，将抛出OutOfMemoryError

### 方法区
1. 各个线程共享的内存区域
2. 存储已被虚拟机加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据
3. 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError

### 运行时常量池
1. 用于存放编译期生成的各种字面量和符号引用，类加载后进入方法区的运行时常量池中存放
2. 运行期间可以放入新的常量