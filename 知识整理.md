# 知识整理

## 面向对象
把整个需求按照特定、功能进行划分，将共性的部分封装成对象，创建对象是为了描述某个事物在解决问题的步骤中的行为。

面向过程：分析出实现需求需要的步骤，通过函数实现步骤，依次调用

### 三大基本特征
- 封装
隐藏对象的属性和实现细节，仅对外公开接口。
增强安全性和简化编程
- 继承
子类继承父类的特征和行为，抽取共有特征和方法形成高一层的类
- 多态
一个类的实例的相同方法在不同的情形有不同的表现形式.
继承-重写-父类引用指向子类的对象

### 五大基本原则
- 单一职责原则(SRP)
一个类只负责专一事件，结构单一。
- 开放封闭原则(OCP)
对扩展开放，对修改关闭
- 里式替换原则(LSP)
对父类的调用同样适用于子类
- 依赖倒置原则(DIP)
高层次的模块不应该依赖于低层次的模块，应该都依赖于抽象.
- 接口隔离原则(ISP)
客户端不应该被迫依赖他们不使用的方法

## 平台无关性
通过JVM隔离操作系统区别，实现跨平台.
JVM还支持kotlin/groovy/jruby/jython/scala

## 值传递
java只有值传递，没有引用传递，方法传递的是引用的值(地址)，而不是引用

## 封装、继承、多态
方法重写：同样的方法名、参数、返回值类型(可以是子类)
方法重载：同样的方法名、不同的参数(个数/类型/顺序不同).仅仅不同的返回值类型不算重载.
继承和实现：可以实现多接口，不允许多继承，继承是is-a,实现是like-a.
构造函数与默认构造函数:default constructor是Java编译器添加到你的代码，如果没有明确的构造函数可用的构造函数。默认构造函数调用没有参数的超类构造函数。

## JAVA基本数据类型
- byte 8bit  -128~127(2的7次方)
- char 16bit
- short 16bit -32768~32767(2的15次方)
- int   32bit -2的31次方~2的31次方-1
- float 32bit -3.402823e38 ~ +3.402823e38
- long  64bit 
- double 64bit -1.79769313486232e308 ~ +1.79769313486232e308
- boolean 
JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。

整型类型的缓冲池大小都是-128\~127

## substring
1.7 Arrays.copyOfRange 拷贝数组
1.6 修改offset & count 
如果你有一个很长很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。
```java
x = x.substring(x, y) + ""
```

## replaceFirst、replaceAll、replace 区别
replace 不支持正则，全替换
replaceFirst 只替换第一次匹配的值 支持正则
replaceAll 全替换，支持正则

## String 对“+”的重载、字符串拼接的几种方式和区别
String的+操作根本不是重载，他只是JVM做的有个简化操作，实际上还是调用了StringBuilder进行相加。

Stringbuffer 加了synchronized 效率低于StringBuilder

## String.valueOf 和 Integer.toString 的区别
String.valueOf 提供了不同的参数类型的方法重载，当它是Interger类型的时候 调用的是Integer.toString方法

```java
public static String toString(int i) {
    if (i == Integer.MIN_VALUE) //等于最小值直接返回最小值字符串，避免getChars方法遇到最小值发生错误
        return "-2147483648"; 
    //判断i的位数，若位负数增加1位用来保存符号位
    int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);
    char[] buf = new char[size];
    //将i转换位buf符号数组
    getChars(i, size, buf);
    //因为buf数组是在方法内部生成，其他地方不会有其引用，所以直接将其引用给String内部的value保存，用来初始化String
    return new String(buf, true);
}
```

## switch 对 String 的支持
java中switch支持String，是利用String的hash值，本质上是switch-int结构。并且利用到了equals方法来防止hash冲突的问题。最后利用switch-byte结构，精确匹配。

## 字符串池、常量池（运行时常量池、Class 常量池）、intern

字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）

class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。 符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：
- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符
常量池的每一项常量都是一个表，一共有如下表所示的11种各不相同的表结构数据，这每个表开始的第一位都是一个字节的标志位（取值1-12），代表当前这个常量属于哪种常量类型

jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。

link:https://blog.csdn.net/vegetable_bird_001/article/details/51278339